<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game with Improved Scoring</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #gameCanvas {
            background-color: #87CEEB;
        }

        #gameOverContainer {
            width: 80%;
            max-width: 300px;
            background-color: #fff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            color: #D8000C;
        }

        #gameOverContainer h2, #gameOverContainer h3 {
            color: #D8000C;
        }

        #leaderboard {
            text-align: left;
            margin-top: 20px;
        }

        #leaderboard ul {
            background-color: #f7f7f7;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }

        #leaderboard li {
            background-color: #e9e9e9;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-weight: bold;
            color: #333;
        }

        #playAgainButton {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            width: 100%; /* Makes the button expand to the full width of its parent container */
        }

        /* Improve overall alignment and presentation */
        body, html {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="gameOverContainer"
     style="display: none; text-align: center; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
    <h2>GAME OVER</h2>
    <button id="playAgainButton">Play Again</button>
    <div id="leaderboard">
        <h3>Leaderboard</h3>
        <ul id="scoresList"></ul>
    </div>
</div>

<script>
    const backgroundImage = new Image();
    const greyPlatformImage = new Image()
    const redPlatformImage = new Image();
    const playerImage = new Image();
    backgroundImage.src = './res/background.jpg'; // Set the source after defining the onload handler
    playerImage.src = './res/player.png'; // Update the path to your player image
    greyPlatformImage.src = './res/greyPlatform.png';
    redPlatformImage.src = './res/redPlatform.png';
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game settings
    const gravity = 0.4;
    const friction = 0.8;
    const baseJump = -10;
    // Drawing setting for player printing
    const playerImageScale = 2.5;
    // Game Variables
    let player = null
    let platforms = [];
    let platformId = 0;
    let enemySpeed = 1; // Adjust this value to find a suitable speed

    initPlatformsAndPlayer();

    // Scoring
    let score = 0;
    let landedPlatforms = new Set(); // Track IDs of platforms the player has landed on

    // Key Listener
    let keys = [];
    window.addEventListener('keydown', function (e) {
        keys[e.keyCode] = true;
        if (e.keyCode == 32 && !player.jumping) {
            player.jumping = true;
            player.velY = baseJump;
        }
    });
    window.addEventListener('keyup', function (e) {
        keys[e.keyCode] = false;
    });

    function addNewPlatform() {
        // This assumes platformId is globally tracked and increments with each new platform
        let hasEnemy = Math.random() < 0.05; // 5% chance to add an enemy
        if (platformId % 20 === 0) { // Example: Add a guaranteed enemy on every 20th platform
            hasEnemy = true;
        }

        const newPlatform = {
            id: platformId++,
            x: Math.random() * (canvas.width - 100),
            y: 0, // Position for new platforms at the top
            width: 100,
            height: 10,
            standingTime: 0,
            enemy: hasEnemy ? {
                type: Math.random() < 0.5 ? 'Type1' : 'Type2',
                x: Math.random() * 80, // Adjust starting position within the platform
                movingDirection: Math.random() < 0.5 ? -1 : 1, // Randomize initial direction for Type2
                width: 20,
                height: 20
            } : null
        };

        platforms.push(newPlatform);
    }

    function initPlatformsAndPlayer() {
        player = {
            x: canvas.width / 2,
            y: canvas.height - 150,
            width: 25,
            height: 25,
            speed: 5,
            velX: 0,
            velY: 0,
            jumping: false
        };


        for (let i = 0; i < 10; i++) {
            let hasEnemy = Math.random() < 0.05 || i === 5; // Ensure platform 5 has an enemy for testing
            platforms.push({
                id: platformId++,
                x: Math.random() * (canvas.width - 100),
                y: canvas.height - (100 * i) - 50,
                width: 100,
                height: 10,
                standingTime: 0,
                enemy: hasEnemy ? {
                    type: Math.random() < 0.5 ? 'Type1' : 'Type2',
                    x: 20, // Starting position on the platform, ensure it's within bounds
                    movingDirection: 1, // Direction for Type2 enemy movement
                    width: 20, // Enemy width
                    height: 20 // Enemy height
                } : null
            });
        }

        platforms.forEach(platform => {
            if (platform.enemy && platform.enemy.type === 'Type2') {
                // Adjust speed or direction based on game logic
                platform.enemy.x += platform.enemy.movingDirection * enemySpeed; // Movement speed
                if (platform.enemy.x <= 0) {
                    platform.enemy.x = 0; // Prevent moving beyond the left edge
                    platform.enemy.movingDirection *= -1; // Change direction
                } else if (platform.enemy.x + platform.enemy.width >= platform.width) {
                    platform.enemy.x = platform.width - platform.enemy.width; // Prevent moving beyond the right edge
                    platform.enemy.movingDirection *= -1; // Change direction
                }
            }
        });
    }


    function drawPlayer() {
        let playerHeightToAdd = canvas.height - player.y === player.height ? 10 : 0;

        // Calculate the new size based on the scale factor
        const drawWidth = player.width * playerImageScale;
        const drawHeight = player.height * playerImageScale;

        // Adjust the draw position so that the player's logical and visual positions align
        const drawX = player.x - (drawWidth - player.width) / 2;
        const drawY = player.y - (drawHeight - player.height) / 2;

        // Draw the player image with the new size and adjusted position
        ctx.drawImage(playerImage, drawX, drawY - playerHeightToAdd, drawWidth, drawHeight);
    }

    function drawPlatforms() {
        let platformImage = null;

        platforms.forEach(platform => {
            platformImage = (platform.enemy) ? redPlatformImage : greyPlatformImage
            ctx.drawImage(platformImage, platform.x, platform.y, platform.width + 5, platform.height + 10);
            // Check if platform ID is divisible by 10 (and not the first platform)
            if (platform.id % 10 === 0 && platform.id !== 0) {
                ctx.fillStyle = 'white'; // Text color
                ctx.font = '12px Arial'; // Font size and family
                // Calculate text position to center it on the platform
                let text = platform.id.toString();
                let textWidth = ctx.measureText(text).width;
                let textX = platform.x + (platform.width - textWidth) / 2;
                let textY = platform.y + (platform.height / 2) + 6; // Adjust to center text vertically
                ctx.fillText(text, textX, textY);
            }
            if (platform.enemy) {
                ctx.fillStyle = platform.enemy.type === 'Type1' ? 'red' : 'blue';
                let enemyX = platform.x + platform.enemy.x; // Calculate absolute position
                ctx.fillRect(enemyX, platform.y - platform.enemy.height, platform.enemy.width, platform.enemy.height);
            }
        });
    }

    function isGameOver() {
        let gameOver = player.y + player.height >= canvas.height && score !== 0;

        if (!gameOver) {
            platforms.forEach(platform => {
                if (platform.enemy) {
                    let enemyX = platform.x + platform.enemy.x;
                    let enemyY = platform.y - platform.enemy.height; // Assuming the enemy is on top of the platform

                    // Check for collision with the enemy
                    if (player.x < enemyX + platform.enemy.width &&
                        player.x + player.width > enemyX &&
                        player.y < enemyY + platform.enemy.height &&
                        player.y + player.height > enemyY) {
                        gameOver = true; // Set the game over state to true
                    }
                }
            });
        }
        return gameOver
    }

    function startGame() {
        platforms = [];
        platformId = 1;
        score = 0;
        landedPlatforms.clear()
        initPlatformsAndPlayer();
        // Hide the game over container
        document.getElementById('gameOverContainer').style.display = 'none';
        window.requestAnimationFrame(updateGame);
    }

    function saveScore(score) {
        const scores = JSON.parse(localStorage.getItem('scores')) || [];
        scores.push(score);
        scores.sort((a, b) => b - a);
        scores.splice(10); // Keep only top 10 scores
        localStorage.setItem('scores', JSON.stringify(scores));
    }

    function getTopScores() {
        return JSON.parse(localStorage.getItem('scores')) || [];
    }

    function updateLeaderboard() {
        const scoresList = document.getElementById('scoresList');
        scoresList.innerHTML = ''; // Clear current list
        const topScores = getTopScores();
        topScores.forEach(score => {
            const li = document.createElement('li');
            li.textContent = score;
            scoresList.appendChild(li);
        });
    }

    function updateGame() {
        // Background
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);

        // At the beginning of your game update loop, check if it's game over
        if (isGameOver()) {
            // Stop the game loop or handle game over
            saveScore(score); // Assuming 'score' is your current game score
            updateLeaderboard();
            document.getElementById('gameOverContainer').style.display = 'block';
            return; // Stops the animation loop
        }

        // Player movement logic
        if (keys[39]) { // Right arrow key
            if (player.velX < player.speed) {
                player.velX++;
                //player.velX += player.speed;
            }
        }
        if (keys[37]) { // Left arrow key
            if (player.velX > -player.speed) {
                player.velX--;
            }
        }

        player.velX *= friction;
        player.velY += gravity;
        player.x += player.velX;
        player.y += player.velY;

        // Screen scroll logic
        if (player.y < canvas.height / 4) {
            let deltaY = Math.abs(player.velY);
            player.y += deltaY;
            platforms.forEach(platform => platform.y += deltaY);
        }

        // Reset standing time for all platforms
        platforms.forEach(platform => platform.standingTime > 0 && platform.standingTime++);

        // Assume no platform is being stood on at the start of each frame
        let standingOnPlatform = false;
        platforms.forEach(platform => {
            // Collision with the platform
            if (player.x < platform.x + platform.width && player.x + player.width > platform.x &&
                player.y < platform.y && player.y + player.height > platform.y && player.velY >= 0) {

                // Player lands on platform logic
                player.jumping = false;
                player.velY = 0;
                player.y = platform.y - player.height;
                standingOnPlatform = true; // Player is standing on a platform this frame

                // Mark platform as landed for scoring
                if (!landedPlatforms.has(platform.id)) {
                    score++;
                    landedPlatforms.add(platform.id);
                }

                // Increment standingTime since player is standing on this platform
                if (platform.standingTime === 0) {
                    platform.standingTime = 1; // Start counting from 1
                } else {
                    platform.standingTime++; // Increment each frame player stands on the platform
                }
            }

            // Make the platform fall if standingTime exceeds 3 seconds (180 frames at 60fps)
            if (platform.standingTime > 180) {
                let t = canvas.height - platform.y
                for (let gap = t; gap > 0; gap -= 10) {
                    platform.y += gap * 0.5 // Make the platform fall
                }
            }
        });

        // Reset standingTime for platforms the player is not standing on anymore
        platforms.forEach(platform => {
            if (!standingOnPlatform && platform.standingTime > 0) {
                platform.standingTime = 0; // Reset if player is no longer on the platform
            }
        });

        // It might be useful to clean up platforms that have fallen out of view to keep the game performant.
        platforms = platforms.filter(platform => platform.y < canvas.height + 50);

        // Reset standingTime for platforms the player is not standing on anymore
        platforms.forEach(platform => {
            if (!standingOnPlatform && platform.standingTime > 0) {
                platform.standingTime = 0; // Reset if player is no longer on the platform
            }
        });

        // Edge collision logic
        if (player.x >= canvas.width - player.width) player.x = canvas.width - player.width;
        else if (player.x <= 0) player.x = 0;

        if (player.y >= canvas.height - player.height) {
            player.y = canvas.height - player.height;
            player.jumping = false;
            player.velY = 0;
        }

        // Check if a new platform is needed
        const highestPlatformY = Math.min(...platforms.map(p => p.y));
        if (highestPlatformY > 100) { // Adjust based on your game's needs
            addNewPlatform(); // Add a new platform at the top
        }

        // Optional: Remove platforms that have moved off the screen
        platforms = platforms.filter(platform => platform.y < canvas.height + 50);

        platforms.forEach(platform => {
            if (platform.enemy && platform.enemy.type === 'Type2') {
                // Adjust speed or direction based on game logic
                platform.enemy.x += platform.enemy.movingDirection * enemySpeed; // Movement speed
                if (platform.enemy.x <= 0) {
                    platform.enemy.x = 0; // Prevent moving beyond the left edge
                    platform.enemy.movingDirection *= -1; // Change direction
                } else if (platform.enemy.x + platform.enemy.width >= platform.width) {
                    platform.enemy.x = platform.width - platform.enemy.width; // Prevent moving beyond the right edge
                    platform.enemy.movingDirection *= -1; // Change direction
                }
            }
        });

        // Drawing logic
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        drawPlayer();
        drawPlatforms();

        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.fillText("Score: " + score, 10, 30);

        requestAnimationFrame(updateGame);
    }

    document.getElementById('playAgainButton').addEventListener('click', startGame);

    updateGame();
</script>
</body>
</html>
