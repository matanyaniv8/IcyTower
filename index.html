<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game with Improved Scoring</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #gameCanvas {
            background-color: #87CEEB;
        }

        #gameOverContainer h2, #gameOverContainer h3 {
            color: #D8000C;
        }

        #leaderboard ul {
            list-style-type: none;
            padding: 0;
        }

        #leaderboard li {
            margin: 5px 0;
            color: #000;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="gameOverContainer"
     style="display: none; text-align: center; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
    <h2>GAME OVER</h2>
    <button id="playAgainButton">Play Again</button>
    <div id="leaderboard">
        <h3>Leaderboard</h3>
        <ul id="scoresList"></ul>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game settings
    const gravity = 0.4;
    const friction = 0.8;
    const baseJump = -10;

    // Player
    /* let player = {
         x: canvas.width / 2,
         y: canvas.height - 150,
         width: 20,
         height: 20,
         speed: 5,
         velX: 0,
         velY: 0,
         jumping: false
     };*/

    let player = null
    let platforms = [];
    let platformId = 0;
    initPlatformsAndPlayer();

    // Scoring
    let score = 0;
    let landedPlatforms = new Set(); // Track IDs of platforms the player has landed on

    // Key Listener
    let keys = [];
    window.addEventListener('keydown', function (e) {
        keys[e.keyCode] = true;
        if (e.keyCode == 32 && !player.jumping) {
            player.jumping = true;
            player.velY = baseJump;
        }
    });
    window.addEventListener('keyup', function (e) {
        keys[e.keyCode] = false;
    });

    function addNewPlatform() {
        // This assumes platformId is globally tracked and increments with each new platform
        let hasEnemy = Math.random() < 0.05; // 5% chance to add an enemy
        if (platformId % 20 === 0) { // Example: Add a guaranteed enemy on every 20th platform
            hasEnemy = true;
        }

        const newPlatform = {
            id: platformId++,
            x: Math.random() * (canvas.width - 50),
            y: 0, // Position for new platforms at the top
            width: 100,
            height: 10,
            standingTime: 0,
            enemy: hasEnemy ? {
                type: Math.random() < 0.5 ? 'Type1' : 'Type2',
                x: Math.random() * 80, // Adjust starting position within the platform
                movingDirection: Math.random() < 0.5 ? -1 : 1, // Randomize initial direction for Type2
                width: 20,
                height: 20
            } : null
        };

        platforms.push(newPlatform);
    }

    function initPlatformsAndPlayer() {
        player = {
            x: canvas.width / 2,
            y: canvas.height - 150,
            width: 20,
            height: 20,
            speed: 5,
            velX: 0,
            velY: 0,
            jumping: false
        };


        for (let i = 0; i < 10; i++) {
            let hasEnemy = Math.random() < 0.05 || i === 5; // Ensure platform 5 has an enemy for testing
            platforms.push({
                id: platformId++,
                x: Math.random() * (canvas.width - 50),
                y: canvas.height - (100 * i) - 50,
                width: 100,
                height: 10,
                standingTime: 0,
                enemy: hasEnemy ? {
                    type: Math.random() < 0.5 ? 'Type1' : 'Type2',
                    x: 20, // Starting position on the platform, ensure it's within bounds
                    movingDirection: 1, // Direction for Type2 enemy movement
                    width: 20, // Enemy width
                    height: 20 // Enemy height
                } : null
            });
        }
        platforms.forEach(platform => {
            if (platform.enemy && platform.enemy.type === 'Type2') {
                // Adjust speed or direction based on game logic
                platform.enemy.x += platform.enemy.movingDirection * 2; // Movement speed
                if (platform.enemy.x <= 0 || platform.enemy.x >= platform.width - platform.enemy.width) {
                    platform.enemy.movingDirection *= -1; // Change direction
                }
            }
        });
    }

    function isGameOver() {
        let gameOver = player.y + player.height >= canvas.height && score !== 0;

        if (!gameOver) {
            platforms.forEach(platform => {
                if (platform.enemy) {
                    let enemyX = platform.x + platform.enemy.x;
                    let enemyY = platform.y - platform.enemy.height; // Assuming the enemy is on top of the platform

                    // Check for collision with the enemy
                    if (player.x < enemyX + platform.enemy.width &&
                        player.x + player.width > enemyX &&
                        player.y < enemyY + platform.enemy.height &&
                        player.y + player.height > enemyY) {
                        gameOver = true; // Set the game over state to true
                    }
                }
            });
        }
        return gameOver
    }

    function startGame() {
        platforms = [];
        platformId = 0;
        score = 0;
        initPlatformsAndPlayer();
        // Hide the game over container
        document.getElementById('gameOverContainer').style.display = 'none';
        window.requestAnimationFrame(updateGame);
    }

    function saveScore(score) {
        const scores = JSON.parse(localStorage.getItem('scores')) || [];
        scores.push(score);
        scores.sort((a, b) => b - a);
        scores.splice(10); // Keep only top 10 scores
        localStorage.setItem('scores', JSON.stringify(scores));
    }

    function getTopScores() {
        return JSON.parse(localStorage.getItem('scores')) || [];
    }

    function updateLeaderboard() {
        const scoresList = document.getElementById('scoresList');
        scoresList.innerHTML = ''; // Clear current list
        const topScores = getTopScores();
        topScores.forEach(score => {
            const li = document.createElement('li');
            li.textContent = score;
            scoresList.appendChild(li);
        });
    }

    function updateGame() {
        platforms.forEach(platform => {
            if (platform.enemy && platform.enemy.type === 'Type2') {
                // Adjust speed or direction based on game logic
                platform.enemy.x += platform.enemy.movingDirection * 2; // Movement speed
                if (platform.enemy.x <= 0 || platform.enemy.x >= platform.width - platform.enemy.width) {
                    platform.enemy.movingDirection *= -1; // Change direction
                }
            }
        });

        // At the beginning of your game update loop, check if it's game over
        if (isGameOver()) {
            // Stop the game loop or handle game over
            saveScore(score); // Assuming 'score' is your current game score
            updateLeaderboard();
            document.getElementById('gameOverContainer').style.display = 'block';
            return; // Stops the animation loop
        } /*else {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the background image
            ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);

            // Continue with the rest of your game rendering...

            requestAnimationFrame(updateGame);
        }*/

        // Player movement logic
        if (keys[39]) { // Right arrow key
            if (player.velX < player.speed) {
                player.velX++;
                //player.velX += player.speed;
            }
        }
        if (keys[37]) { // Left arrow key
            if (player.velX > -player.speed) {
                player.velX--;
            }
        }

        player.velX *= friction;
        player.velY += gravity;
        player.x += player.velX;
        player.y += player.velY;

        // Screen scroll logic
        if (player.y < canvas.height / 4) {
            let deltaY = Math.abs(player.velY);
            player.y += deltaY;
            platforms.forEach(platform => platform.y += deltaY);
        }

        // Reset standing time for all platforms
        platforms.forEach(platform => platform.standingTime > 0 && platform.standingTime++);

        // Assume no platform is being stood on at the start of each frame
        let standingOnPlatform = false;
        platforms.forEach(platform => {
            // Collision with the platform
            if (player.x < platform.x + platform.width && player.x + player.width > platform.x &&
                player.y < platform.y && player.y + player.height > platform.y && player.velY >= 0) {

                // Player lands on platform logic
                player.jumping = false;
                player.velY = 0;
                player.y = platform.y - player.height;
                standingOnPlatform = true; // Player is standing on a platform this frame

                // Mark platform as landed for scoring
                if (!landedPlatforms.has(platform.id)) {
                    score++;
                    landedPlatforms.add(platform.id);
                }

                // Increment standingTime since player is standing on this platform
                if (platform.standingTime === 0) {
                    platform.standingTime = 1; // Start counting from 1
                } else {
                    platform.standingTime++; // Increment each frame player stands on the platform
                }
            }

            // Make the platform fall if standingTime exceeds 3 seconds (180 frames at 60fps)
            if (platform.standingTime > 180) {
                let t = canvas.height - platform.y
                for (let gap = t; gap > 0; gap -= 10) {
                    platform.y += gap * 0.5 // Make the platform fall
                }
            }
        });

        // Reset standingTime for platforms the player is not standing on anymore
        platforms.forEach(platform => {
            if (!standingOnPlatform && platform.standingTime > 0) {
                platform.standingTime = 0; // Reset if player is no longer on the platform
            }
        });

        // It might be useful to clean up platforms that have fallen out of view to keep the game performant.
        platforms = platforms.filter(platform => platform.y < canvas.height + 50);

        // Reset standingTime for platforms the player is not standing on anymore
        platforms.forEach(platform => {
            if (!standingOnPlatform && platform.standingTime > 0) {
                platform.standingTime = 0; // Reset if player is no longer on the platform
            }
        });

        // Edge collision logic
        if (player.x >= canvas.width - player.width) player.x = canvas.width - player.width;
        else if (player.x <= 0) player.x = 0;

        if (player.y >= canvas.height - player.height) {
            player.y = canvas.height - player.height;
            player.jumping = false;
            player.velY = 0;
        }

// Check if a new platform is needed
        const highestPlatformY = Math.min(...platforms.map(p => p.y));
        if (highestPlatformY > 100) { // Adjust based on your game's needs
            addNewPlatform(); // Add a new platform at the top
        }

        // Optional: Remove platforms that have moved off the screen
        platforms = platforms.filter(platform => platform.y < canvas.height + 50);

        platforms.forEach(platform => {
            if (platform.enemy && platform.enemy.type === 'Type2') {
                // Move enemy
                platform.enemy.x += platform.enemy.movingDirection * 2; // Adjust speed as needed
                // Turn around at platform edges
                if (platform.enemy.x <= platform.x || platform.enemy.x + platform.enemy.width >= platform.x + platform.width) {
                    platform.enemy.movingDirection *= -1;
                }
            }
        });


        // Drawing logic
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'red';
        ctx.fillRect(player.x, player.y, player.width, player.height);

        platforms.forEach(platform => {
            ctx.fillStyle = 'black';
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            // Check if platform ID is divisible by 10 (and not the first platform)
            if (platform.id % 10 === 0 && platform.id !== 0) {
                ctx.fillStyle = 'white'; // Text color
                ctx.font = '12px Arial'; // Font size and family
                // Calculate text position to center it on the platform
                let text = platform.id.toString();
                let textWidth = ctx.measureText(text).width;
                let textX = platform.x + (platform.width - textWidth) / 2;
                let textY = platform.y + (platform.height / 2) + 6; // Adjust to center text vertically
                ctx.fillText(text, textX, textY);
            }
            if (platform.enemy) {
                ctx.fillStyle = platform.enemy.type === 'Type1' ? 'red' : 'blue';
                let enemyX = platform.x + platform.enemy.x; // Calculate absolute position
                ctx.fillRect(enemyX, platform.y - platform.enemy.height, platform.enemy.width, platform.enemy.height);
            }
        });

        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.fillText("Score: " + score, 10, 30);

        requestAnimationFrame(updateGame);
    }

    document.getElementById('playAgainButton').addEventListener('click', startGame);

    updateGame();
</script>
</body>
</html>
